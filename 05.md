# MIP-05

## WIP ISSUES

- How do we sync groups on which notification server to use? Do we need to?
- Improve formats of the token gossip events
- Recalculate bytes estimates for tokens
- well-known vs hardcoded, etc?
- storage of tokens
- do we need decoys?

## Push Notifications

`draft` `optional`

This document defines a privacy-preserving approach to delivering push notifications for Marmot group messages through Apple and Google push notification services while minimizing metadata leakage and protecting user privacy.

## Overview

Users expect timely push notifications for new messages in their chat applications. While most users accept that notifications go through Apple (APNs) and Google (FCM) push notification services, a subset of privacy-conscious users (activists, journalists, etc.) require the ability to opt-out of these centralized services.

This specification provides a system where:

1. **Encrypted tokens** are shared among group members instead of direct device tokens
2. **Notification server** acts as a privacy-preserving intermediary that cannot determine message content or sender
3. **User control** allows opting out of push notifications entirely
4. **Minimal metadata** is exposed to Apple/Google (just that a notification occurred, not content or sender)

## Architecture

### Components

1. **Client Application**: Marmot-compatible messaging app that generates encrypted tokens
2. **Notification Server**: State-minimized server that decrypts tokens and triggers APNs/FCM
3. **Apple/Google Services**: Standard push notification infrastructure (APNs/FCM)

### Privacy Properties

The system is designed to minimize information leakage:

- **Apple/Google learn**: A notification occurred for a device (unavoidable with push).
- **Apple/Google CANNOT learn**: Message content, sender identity, recipient identity, group membership, sender IP address (only relays observer sender IPs)
- **Notification server learns**: Timing of notification events arriving at relays
- **Notification server CANNOT learn**: Message content, sender identity, recipient identity, group membership, which user owns which device token, sender IP address (only relays observe sender IPs)
- **Relays learn**: Sender IP address, size and timing of notification trigger events
- **Relays CANNOT learn**: Message content, sender identity (events are gift-wrapped), recipient identity, group membership, which device tokens are being triggered, relationship between notification events and specific users
- **Critical privacy property**: Ephemeral keypairs for token encryption prevent the server from linking encrypted tokens to user identities, even when combined with gift-wrapped notification events

## Encrypted Token Generation

### Device Token Registration

When a user enables push notifications, the client:

1. **Obtains device token** from the native push service using standard OS APIs:
   - iOS: APNs token via `UNUserNotificationCenter`
   - Android: FCM token via Firebase SDK
2. **Uses notification server's Nostr public key** (hardcoded in client or discovered via NIP-89 in future versions)
3. **Discovers inbox relays** via kind 10050 event published by the notification server public key.
4. **Encrypts device token** using the server's public key (with random nonce for probabilistic encryption)
5. **Shares encrypted token** with all group members

### Encryption Format

Encrypted tokens use **probabilistic encryption** to ensure that the same device token produces different ciphertexts for each group, preventing cross-group correlation:

```
// Server's Nostr public key (hardcoded or discovered via NIP-89)
server_pubkey = "8f3e2b1a4c5d6e7f..."  // 32-byte secp256k1 pubkey

// Generate ephemeral keypair for this token encryption
ephemeral_privkey = random_bytes(32)  // Random secp256k1 private key
ephemeral_pubkey = secp256k1.get_pubkey(ephemeral_privkey)  // Derive public key

// Derive conversation key using ECDH
conversation_key = secp256k1_ecdh(ephemeral_privkey, server_pubkey)
encryption_key = HKDF-Expand(conversation_key, "mip05-token-encryption", 32)

// Generate random nonce for probabilistic encryption
nonce = random_bytes(12)

// Construct payload with platform identifier
payload = platform_identifier || 0x00 || device_token  // "apns" or "fcm" + null byte + token

// Encrypt with ChaCha20-Poly1305
ciphertext = ChaCha20-Poly1305.encrypt(
    key: encryption_key,
    nonce: nonce,
    plaintext: payload,
    aad: ""  // Empty AAD
)

// Token package includes ephemeral pubkey, nonce, and ciphertext
encrypted_token = ephemeral_pubkey || nonce || ciphertext  // 32-byte pubkey + 12-byte nonce + ciphertext
```

**Probabilistic Property**: The combination of ephemeral keypairs and random nonces ensures that encrypting the same device token multiple times (for different groups) produces different ciphertexts with no linkage to the user's identity. This prevents the notification server from:
1. Correlating a user's presence across multiple groups
2. Linking encrypted tokens back to the user who created them
3. Connecting notification trigger events to specific device tokens

**Server Decryption**: The server decrypts by:
1. Extracting the first 32 bytes as the ephemeral public key
2. Extracting the next 12 bytes as the nonce
3. Using the ephemeral public key and its private key to derive the same conversation key via ECDH
4. Decrypting the remaining bytes as the ciphertext
5. Extracting the platform identifier and device token from the decrypted payload

### Server Discovery

The notification server's Nostr public key is typically **hardcoded in the client** at build time. Future versions may support NIP-89 discovery or manual entry.

Clients SHOULD query the server's kind 10050 event to discover inbox relays dynamically.

## Token Distribution

### Gossip-Based Token Synchronization

Encrypted tokens are shared using a **gossip-style protocol** where each group member maintains a complete list of all active device tokens in the group. This approach provides redundancy, fast convergence, and works well even when members are offline.

All token distribution uses **standard Marmot Group Messages** (MIP-03) as application messages inside `kind: 445` Group Events. The inner application messages use the following Nostr event kinds:

#### Token Request (kind 447)

When a device joins a group or needs to refresh its view of active tokens, it sends an unsigned `kind: 447` event as an application message:

```json
{
    "kind": 447,
    "created_at": 1693876700,
    "pubkey": "<sender_nostr_pubkey>",
    "content": "",
    "tags": [
        ["token", "<hex-encoded-bytes>", "<server_pubkey>"]
    ]
}
```

**Tags**:
- **token**: One or more `token` tags, each containing:
  - First value: Complete encrypted token (ephemeral_pubkey || nonce || ciphertext) as hex
  - Second value: The notification server's public key used for encryption (hex)
- **nonce**: Random nonce to prevent duplicate processing and tie responses to requests

**Notes**:
- The requesting device's own tokens are included in `token` tags to bootstrap them into the group immediately
- The MLS leaf index is implicit from the MLS sender identity (verified by MLS layer)
- This event MUST remain **unsigned** (no `sig` field) per MIP-03 security requirements

#### Token List Response (kind 448)

Any group member may respond with their complete view of all tokens as an unsigned `kind: 448` event:

```json
{
    "kind": 448,
    "created_at": 1693876750,
    "pubkey": "<sender_nostr_pubkey>",
    "content": "",
    "tags": [
        ["token", "<encrypted_token_hex>", "<server_pubkey>", "<leaf_index>"],
        ["token", "<encrypted_token_hex>", "<server_pubkey>", "<leaf_index>"],
        ["e", "<event_id of 447 you're responding to>"]
    ]
}
```

**Tags**:
- **token**: One or more `token` tags, each containing:
  - First value: Complete encrypted token as hex
  - Second value: Notification server's public key (hex)
  - Third value: MLS leaf index (decimal string) of the device that owns this token
- **responding_to**: The nonce from the original `kind: 447` request

**Response behavior**:
- Members SHOULD add a random delay (0-2 seconds) before responding to avoid simultaneous responses
- Members SHOULD skip responding if they observe another member already responded to the same nonce
- Multiple responses are acceptable and help ensure new members receive complete information
- This event MUST remain **unsigned** (no `sig` field) per MIP-03 security requirements

### Token Storage

Each client maintains a local token store (e.g., SQLite database) with the following structure:

```rust
struct StoredToken {
    encrypted_token: Vec<u8>,    // Encrypted token bytes
    server_pubkey: PublicKey,    // Notification server public key
    leaf_index: LeafIndex,       // Which device owns this token
    added_at: i64,               // Timestamp for pruning stale entries
}
```

**Storage properties**:
- Tokens are indexed by leaf_index for efficient removal
- Tokens older than 35 days SHOULD be pruned (spec recommends 30-day refresh)
- When MLS Remove operations occur, tokens for removed leaves are automatically deleted

### Gossip Protocol Properties

- **Passive learning**: Members observe all token messages and update their local store, creating natural convergence
- **Redundancy**: Multiple members can respond to requests, ensuring delivery even when some are offline
- **Fast convergence**: New members share their tokens in the request, incorporating them immediately
- **Self-healing**: Members can send token requests at any time to refresh their view
- **Multi-device support**: Each device (MLS leaf) manages its own tokens independently

### Token Update Triggers

Clients SHOULD send token updates when:

- Device first enables notifications in the app (send `kind: 449`)
- Device joins a new group (send `kind: 447` with requester's tokens)
- Device token changes due to OS-initiated refresh (send `kind: 449`)
- Periodic refresh (recommended: every 30 days, send `kind: 449`)

Clients SHOULD send token removal messages when:

- Device disables notifications (send `kind: 450`)
- Device is removed from the group (send `kind: 450` before leaving)
- App is uninstalled (best-effort via OS hooks, send `kind: 450`)

### Automatic Cleanup

When MLS Remove operations occur (user leaves, admin removes user, device removed):

1. All members process the MLS Remove operation
2. All members automatically delete tokens for the removed leaf_index(es)
3. No explicit `kind: 450` (Token Removal) message is required (though it's polite to send one before leaving)

This ensures token lists stay synchronized with actual group membership.


### Multi-Device Scenarios

Each device (MLS leaf) manages tokens independently:

- **Multiple devices**: User with iPhone (leaf 3) and iPad (leaf 7) has tokens at both leaf indices
- **Token updates**: Updating tokens for one device doesn't affect other devices
- **Device removal**: MLS Remove operation automatically triggers token cleanup for that leaf
- **User removal**: All of user's device tokens are removed via cleanup of all their leaf indices

### Implementation Considerations

**Initial join flow:**
1. Device joins group via MLS Add or External Commit
2. Immediately creates and sends a `kind: 447` (Token Request) event including its own tokens
3. Wraps the event in an MLS Application Message and publishes as `kind: 445`
4. Receives `kind: 448` (Token List) responses and merges tokens into local store

**Token management:**
- Devices can send `kind: 447` events at any time to refresh their view
- Use MLS message ordering (epoch + message index) to resolve simultaneous updates
- When processing `kind: 449` (Token Update) events, verify sender's MLS identity
- Prune tokens older than 35 days
- Most groups: ~200 tokens max (~100KB storage per group)

**Event handling:**
- All notification events (447, 448, 449, 450) are MLS Application Messages
- These events follow the same encryption and authentication flow as chat messages (kind 9)
- Inner events MUST be unsigned to prevent leakage if accidentally exposed
- Sender identity is verified through MLS authentication, not event signatures

## Triggering Notifications

### Gift-Wrapped Notification Events

When a user sends a message to a group, their client triggers notifications by publishing a **gift-wrapped Nostr event** to the notification server's inbox relays. This approach:

- **Maintains Nostr-native protocol**: Uses standard Nostr event types
- **Provides sender privacy**: Gift wrap hides the sender's identity from relays
- **Enables relay-based delivery**: Leverages existing Nostr infrastructure
- **Supports asynchronous delivery**: Server processes events from its inbox

### Event Structure

The notification trigger uses [NIP-59 Gift Wrap](https://github.com/nostr-protocol/nips/blob/master/59.md) containing a **kind 446 event**:

**Inner Event (kind 446 - Marmot Notification Request)**:
```json
{
    "kind": 446,
    "content": "[\"encrypted_token_1\", \"encrypted_token_2\", ...]",  // JSON array of hex-encoded encrypted tokens
    "tags": [],
    "pubkey": "<sender_pubkey>",  // For server to derive conversation key
    "created_at": <timestamp>,
    "id": "<event_id>",
    "sig": "<signature>"
}
```

**Size Constraints**: The kind 446 event content is limited by the NIP-59 gift wrap process and the typical relay 64KB event size limit. Each encrypted token in the JSON array is a hex-encoded string:

- **FCM tokens**: ~496 hex characters per encrypted token (32-byte ephemeral pubkey + 12-byte nonce + ~172-byte ciphertext) → max ~125 tokens per event
- **APNs tokens**: ~322 hex characters per encrypted token (32-byte ephemeral pubkey + 12-byte nonce + ~73-byte ciphertext) → max ~190 tokens per event
- **JSON overhead**: Includes quotes, commas, and brackets for the array → subtract ~10-15% from theoretical max
- **Practical limit**: Recommend batching at 80-120 tokens per event to stay well under limits

For groups with more devices than the token limit, clients MUST split notifications across multiple gift-wrapped events. Each device may have multiple tokens (one per platform, or multiple for redundancy), so total tokens can exceed device count.

**Gift Wrap (kind 1059)**:
```json
{
    "kind": 1059,
    "pubkey": "<random_ephemeral_pubkey>",
    "content": "<nip44_encrypted_kind446_event>",
    "tags": [
        ["p", "<notification_server_pubkey>"]
    ],
    "created_at": "<timestamp_with_jitter>",
    "id": "<event_id>",
    "sig": "<signature>"
}
```

### Processing Flow

When a device sends a message to a group:

1. **Collect tokens**: Get all stored encrypted tokens from all active leaves in the group
2. **Filter active leaves**: Only include tokens from leaves that still exist in the MLS tree (removes tokens from departed members)
3. **Add decoys**: Include 2-5 fake encrypted tokens (random bytes matching expected size)
4. **Create kind 446 event**: Set `content` to JSON array of encrypted tokens (just the raw encrypted bytes, no metadata)
5. **Gift wrap**: Encrypt the kind 446 event to the notification server's pubkey
6. **Publish**: Send gift-wrapped event to notification server's inbox relays
7. **Server processes**:
   - Unwraps the gift wrap using its private key
   - Extracts the kind 446 event
   - Decrypts each token using the ephemeral pubkey (extracted from token) and its private key via ECDH
   - Extracts device token from each decrypted payload
   - Sends push notifications to APNs/FCM for valid tokens


### Notification Payload

The push notification sent to APNs/FCM contains **minimal information**:

- **Silent notification**: No content, title, or sender information
- **Content-available flag**: Triggers background fetch in the app
- **Badge increment**: Indicates new activity without specifics

The app fetches and decrypts actual messages when awakened by the notification.

### Notification Server Inbox Relays

The notification server advertises its inbox relays via kind 10050 event. Clients SHOULD publish to all advertised relays to ensure delivery.

## Platform Integration

### Native Push Services Only

This specification requires **native platform tokens**:

- **iOS devices**: APNs tokens from Apple's UNUserNotificationCenter API
- **Android devices**: FCM tokens from Firebase Cloud Messaging SDK

**Important**: iOS clients MUST use APNs tokens directly, not FCM as a proxy. Using FCM for both platforms would allow Google to correlate users across iOS/Android and groups, defeating the probabilistic encryption privacy guarantees.

## Privacy Enhancements

### Tor Support

For maximum privacy, clients SHOULD support publishing gift-wrapped events through Tor:

1. **User setting**: "Use Tor for notifications" (disabled by default)
2. **Tor integration**: Use OS Tor daemon or embedded Tor library
3. **Circuit management**: Use fresh circuits periodically to prevent correlation
4. **Relay connections**: Connect to notification server's inbox relays via Tor

This prevents relays and the notification server from learning the sender's IP address.

### Rate Limiting and DoS Protection

**Server-side**:
- Verify gift wrap and inner event signatures before processing
- Track events per sender pubkey (from kind 446 inner event) for rate limiting
- Maintain minimal ephemeral state (in-memory counters, no long-term storage)

**Client-side**:
- Batch multiple messages into single notification event (1-2 second delay)
- Don't send notifications for every keystroke or unnecessary event

### Event Size Padding

To obscure patterns: ensure kind 446 content reaches minimum size (e.g., 10 tokens) using decoy tokens, use randomized `created_at` timestamps per NIP-59, and leverage gift wrap encryption for consistent appearance.

## Privacy-Only Users

Users who completely opt out of Apple/Google push notifications:

1. **Don't generate tokens**: Skip device token registration entirely
2. **Can still trigger notifications**: Publish kind 1059 gift-wrapped events for groups they're in if desired
3. **Alternative mechanisms**: Rely on background fetch or manual app opening

## Implementation Requirements

### Client Requirements

Clients MUST:
- Support probabilistic encryption (secp256k1 ECDH + ChaCha20-Poly1305) with ephemeral keypairs and random nonces
- Fetch server public key and inbox relays from kind 10050.
- Implement handlers for notification event kinds (447, 448, 449, 450) as MLS Application Messages
- Verify sender's MLS identity matches the inner event's `pubkey` field
- Ensure all notification events remain unsigned (no `sig` field) per MIP-03 requirements
- Maintain local token store indexed by leaf_index with automatic MLS Remove cleanup
- Create gift-wrapped kind 446 events per NIP-59 and publish to server's inbox relays
- Only include tokens from active leaves when triggering notifications

Clients SHOULD:
- Add random delay (0-2 seconds) before responding to token requests
- Passively learn from token messages and prune tokens older than 35 days
- Add 2-5 decoy tokens to kind 446 events
- Support Tor routing and batch notifications
- Implement user opt-out setting for push notifications

### Server Requirements

Servers MUST:
- Implement state-minimized design with no persistent token storage
- Publish kind 10050 inbox relay list and monitor for kind 1059 gift-wrapped events
- Unwrap events per NIP-59, decrypt tokens using ephemeral pubkey from token and server's privkey via ECDH
- Maintain **direct integrations** with both APNs and FCM (no intermediary services)
- Route tokens to appropriate service based on platform identifier
- Silently ignore invalid tokens (decoys, malformed, expired)
- Implement rate limiting per sender pubkey

Servers SHOULD:
- Use ephemeral state mechanisms (in-memory counters) that don't persist across restarts
- Leverage relay-level spam protection and use multiple inbox relays

## Security Considerations

### Threat Model

This specification protects against:

1. **Notification server compromise**: Server cannot read message content, cannot correlate tokens across groups (probabilistic encryption), cannot determine which tokens belong to same user, cannot link tokens to user identities
2. **Relay surveillance**: Gift wrap hides sender identity; only notification server's pubkey is visible
3. **Network surveillance**: Tor support prevents IP correlation; gift wrap encryption hides event content
4. **Apple/Google surveillance**: Only learn that a notification occurred, no content or sender
5. **Token correlation**: Different ciphertext per group prevents cross-group tracking
6. **Recipient enumeration**: Decoys obscure exact recipient count
7. **Malicious group member**: Cannot update/remove other members' tokens (authorization via MLS sender authentication), can see which leaves have tokens but cannot decrypt them for notification server use, cannot forge `kind: 449` or `kind: 450` events for other members due to MLS authentication

### Trust Assumptions

Users must trust:

1. **Notification server operator**: To run advertised code and not log excessively (mitigated by transparency and open source)
2. **Apple/Google**: To deliver notifications (required for push functionality)
3. **Their device OS**: To properly isolate APNs/FCM tokens

The design minimizes trust requirements by:
- Minimizing server state (only ephemeral rate limiting data, no long-term storage)
- Using strong encryption
- Allowing Tor routing
- Supporting complete opt-out

### Attack Scenarios

**Compromised notification server**: Cannot decrypt messages, correlate tokens across groups, determine sender/recipient identities, or link events to users. Could refuse to send notifications (user-visible failure).

**Compromised relay**: Sees encrypted events but cannot decrypt content or determine sender/recipients. Could drop events (mitigated by multiple relays).

**Apple/Google monitoring**: Learn a device received a notification but cannot determine sender, content, group, or message details.

**Network observer**: Sees encrypted events but cannot determine sender, exact recipient count (decoys), or content.

**Malicious group member**: Can send spam requests or fake tokens for their own leaf, but cannot impersonate other leaves, prevent legitimate updates, or break the gossip protocol's redundancy.

## References

- [NIP-59: Gift Wrap](https://github.com/nostr-protocol/nips/blob/master/59.md)
- [Apple Push Notification Service (APNs)](https://developer.apple.com/documentation/usernotifications)
- [Firebase Cloud Messaging (FCM)](https://firebase.google.com/docs/cloud-messaging)
